import { OptionalPropertyIdentity } from "./types/optional";
import { SelfIdentity } from "./types/self";

export enum DError {
  CannotDecode = "#CD!",
  NoSuchProperty = "#NSP!",
}

export type ContextConfiguration = {
  i18n?: {
    [key: string]: RegExp;
  };
};

export type DContext = {
  i18n?: string;
};

export type Validator<T> = (target: unknown) => T | DError;

/**
 * Determines whether the value adheres to a specific constraint.
 */
export type Assertor = {
  isContextful: boolean;
  assertor: ContextfulAssertor | PureAssertor;
};

export type ContextfulAssertor = (context: DContext) => PureAssertor;
export type PureAssertor = (target: unknown) => boolean;

/**
 * Used for assertors that might have context.
 */
export type AssertorFactory = (
  rules: unknown | ContextConfiguration
) => Assertor;

/**
 * This represents a function that will be directly called by the decoder function.
 *
 * It's only concern is to inject the context to a "first-order" validator function generated by brand(),
 * which will check all the assertions. See the definition of String(), Integer()...
 */
export type Typifier<T> = (context?: DContext) => Validator<T>;

export interface Schema {
  [key: string]:
    | Typifier<unknown>
    | Schema
    | SelfIdentity
    | OptionalPropertyIdentity;
}

export type DType<T extends Schema> = T extends infer O
  ? {
      [P in keyof O]: O[P] extends Schema
        ? DType<O[P]>
        : O[P] extends SelfIdentity
        ? DType<T>
        : O[P] extends (context: DContext) => (input: unknown) => infer R
        ? R
        : O[P] extends (input: unknown) => infer R
        ? R
        : never;
    }
  : never;

/**
 * @param initialValidator Determines the raw type.
 * @param assertions Predicates the value needs to "pass".
 * @returns The first-order validator: the function that will try to decode an object property.
 */
export function brand<T>(
  initialValidator: Validator<T>,
  assertions: Assertor[],
  context?: DContext
): Validator<T> {
  return (input) => {
    const initialResult = initialValidator(input) as T | DError.CannotDecode;

    if (initialResult === DError.CannotDecode) {
      return DError.CannotDecode;
    }

    const hasFalseAssertion = assertions.some((assertion) => {
      const { isContextful, assertor } = assertion;

      return (
        (isContextful
          ? (assertor(context) as unknown as ContextfulAssertor)
          : (assertor as PureAssertor))(initialResult) === false
      );
    });

    return hasFalseAssertion
      ? DError.CannotDecode
      : (initialResult as unknown as T);
  };
}

// Sadly needed because of https://github.com/microsoft/TypeScript/issues/37181
